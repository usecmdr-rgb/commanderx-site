import { NextRequest, NextResponse } from "next/server";
import { getSupabaseServerClient } from "@/lib/supabaseServerClient";
import type { Workflow } from "@/types";

// Helper to execute Alpha actions
async function executeAlphaAction(action: string, context: any) {
  switch (action) {
    case "alpha.reorganize":
      return {
        success: true,
        message: "Alpha has reorganized your calendar and priorities",
        data: { reorganized: true },
      };
    case "alpha.scheduleFollowup":
      return {
        success: true,
        message: "Alpha has scheduled a follow-up",
        data: { scheduled: true, followUpDate: new Date().toISOString() },
      };
    default:
      return { success: false, message: `Unknown Alpha action: ${action}` };
  }
}

// Helper to execute Xi actions
async function executeXiAction(action: string, context: any) {
  switch (action) {
    case "xi.summarize":
      return {
        success: true,
        message: "Xi has generated a summary",
        data: { summary: "Summary of recent emails and tasks generated by Xi" },
      };
    case "xi.createTask":
      return {
        success: true,
        message: "Xi has created a new task",
        data: { taskId: `task-${Date.now()}`, created: true },
      };
    default:
      return { success: false, message: `Unknown Xi action: ${action}` };
  }
}

// Helper to execute Mu actions
async function executeMuAction(action: string, context: any) {
  switch (action) {
    case "mu.logMetric":
      return {
        success: true,
        message: "Mu has logged a new metric",
        data: { metricId: `metric-${Date.now()}`, logged: true },
      };
    case "mu.updateMetric":
      return {
        success: true,
        message: "Mu has updated metrics",
        data: { updated: true },
      };
    default:
      return { success: false, message: `Unknown Mu action: ${action}` };
  }
}

// Helper to execute Beta actions
async function executeBetaAction(action: string, context: any) {
  switch (action) {
    case "beta.combineOutputs":
      return {
        success: true,
        message: "Beta has combined outputs from all agents",
        data: { combined: true, summary: "Unified summary from all agents" },
      };
    case "beta.sendSummary":
      return {
        success: true,
        message: "Beta has sent a summary",
        data: { sent: true, recipient: context.recipient || "user" },
      };
    default:
      return { success: false, message: `Unknown Beta action: ${action}` };
  }
}

// Check if workflow condition matches
function checkCondition(condition: Workflow["condition"], context: any): boolean {
  if (!condition) return true;

  const { field, operator, value } = condition;
  const fieldValue = context[field];

  switch (operator) {
    case "contains":
      return fieldValue?.toString().toLowerCase().includes(value?.toString().toLowerCase() || "");
    case "equals":
      return fieldValue === value;
    case "greaterThan":
      return Number(fieldValue) > Number(value);
    case "lessThan":
      return Number(fieldValue) < Number(value);
    case "exists":
      return fieldValue !== undefined && fieldValue !== null;
    default:
      return false;
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { workflowId, trigger, context = {} } = body;

    if (!workflowId && !trigger) {
      return NextResponse.json(
        { error: "Either workflowId or trigger is required" },
        { status: 400 }
      );
    }

    const supabase = getSupabaseServerClient();
    let workflow: Workflow | null = null;

    // If workflowId provided, fetch the workflow
    if (workflowId) {
      const { data, error } = await supabase
        .from("workflows")
        .select("*")
        .eq("id", workflowId)
        .eq("enabled", true)
        .single();

      if (error && error.code !== "PGRST116") {
        throw error;
      }

      workflow = data;
    }

    // If trigger provided, find matching workflows
    if (trigger && !workflow) {
      const { data, error } = await supabase
        .from("workflows")
        .select("*")
        .eq("trigger", trigger)
        .eq("enabled", true);

      if (error && error.code !== "PGRST116") {
        throw error;
      }

      // Find workflow that matches condition
      if (data && data.length > 0) {
        workflow = data.find((w) => checkCondition(w.condition, context)) || data[0];
      }
    }

    if (!workflow) {
      return NextResponse.json(
        { error: "No matching workflow found" },
        { status: 404 }
      );
    }

    // Check condition if workflow has one
    if (workflow.condition && !checkCondition(workflow.condition, context)) {
      return NextResponse.json({
        ok: true,
        message: "Workflow condition not met",
        executed: false,
      });
    }

    // Execute all actions
    const results = [];
    for (const action of workflow.actions) {
      let result;
      
      if (action.startsWith("alpha.")) {
        result = await executeAlphaAction(action, context);
      } else if (action.startsWith("xi.")) {
        result = await executeXiAction(action, context);
      } else if (action.startsWith("mu.")) {
        result = await executeMuAction(action, context);
      } else if (action.startsWith("beta.")) {
        result = await executeBetaAction(action, context);
      } else {
        result = { success: false, message: `Unknown action: ${action}` };
      }

      results.push({
        action,
        ...result,
      });
    }

    return NextResponse.json({
      ok: true,
      workflowId: workflow.id,
      workflowName: workflow.name,
      executed: true,
      results,
    });
  } catch (error: any) {
    console.error("Error running workflow:", error);
    return NextResponse.json(
      { ok: false, error: error.message || "Failed to run workflow" },
      { status: 500 }
    );
  }
}





